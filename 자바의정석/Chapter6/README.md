# 6. 객체지향 프로그래밍1

## 1. 객체지향 언어

+ 1.2 객체지향 언어
  + 객체지향언어의 특징
    1. 코드의 재사용성이 높다. - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
    2. 코드의 관리가 용이하다. - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
    3. 신뢰성이 높은 프로그래밍을 가능하게 한다. - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
      
## 2. 클래스와 객체

+ 2.1 클래스와 객체의 정이와 용도
  + 클래스의 정의 - 클래스란 객체를 정의해 놓은 것이다.
  + 클래스의 용도 - 클래스는 객체를 생성하는데 사용된다.
  + 객체지향이론에서는 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다.

+ 2.2 객체와 인스턴스
  + 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

+ 2.3 객체의 구성요소 - 속성과 기능
  + 객체는 속성과 기능의 집합이라고 할 수 있다.
  + 속성 - __멤버변수__, 특성, 필드, 상태
  + 기능 - __메서드__,함수,행위 

+ 2.4 인스턴스 생성과 사용
  ```
  클래스 변수명;
  변수명 = new 클래스명();
  ```
  + 1. 클래스 변수명; - 클래스에 참조변수 변수명을 선언한다. 메모리에 참조변수 변수명을 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.
  + 2. 변수명 - new 클래스명(); - 연산자 new에 의해 클래스의 인스텉스가 메모리의 빈 공간에 생성되고, 대입연산자(=)에 의해서 생성된 객체의 주소값이 변수명에 저장된다.
  + 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

+ 2.5 객체 배열
  + 많은 수의 객체를 다뤄야 할 때, 객체 역시 배열로 다루는 것이 가능하며 이를 '객체 배열'이라고 한다.
  ```
  클래스[] 변수명 = new 클래스명[배열의 길이];
  변수명[0] = new 클래스명();
  변수명[배열의 길이 -1] = new 클래스명();
  클래스명[] 변수명 = {new 클래스명(), new 클래스명(), new 클래스명()};
  ```
  + 위와 같은 형태로 선언 및 초기화 할 수 있다.

+ 2.6 클래스의 또 다른 정의
  + 객체지향이론의 관점에서 '클래스는 객체를 생성하기 위한 틀이며, 클래스는 속성과 기능으로 정의되어있다'고 할 수 있다.
  + 프로그래밍적인 관점에서 클래스는 '데이터와 함수의 결합', '사용자정의 타입'으로 정의할 수 있다.
  
## 3. 변수와 메서드

+ 3.1 선언위치에 따른 변수의 종류
  + 클래스변수 - 선언위치: 클래스 영역, 생성시기: 클래스가 메모리에 올라갈 때
  + 인스턴스변수 - 선언위치: 클래스 영역, 생성시기: 인스턴스가 생성되었을 때
  + 지역변수 - 선언위치: 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부), 생성시기: 변수 선언문이 수행되었을 때
  + 1. 인스턴스 변수(instance variable) - 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.
  + 2. 클래스 변수(clasee variable) - 선언하는 방법은 인스턴스변수 앞에 static을 붙이기만 하면 되고, 모든 인스턴스가 공통된 변수를 공유하게 한다. class.cv의 형태로 사용된다.
  + 3. 지역 변수(local variable) - 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

+ 3.2 클래스 변수와 인스턴스 변수
  + 인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.

+ 3.3 메서드(method)
  + 메서드를 사용하는 이유
    + 1. 높은 재사용성
    + 2. 중복된 코드의 제거
    + 3. 프로그램 구조화
        
+ 3.4 메서드의 선언과 구현
  + 메서드는 크게 두 부분, 선언부와 구현부로 이루어져 있다.
  + 메서드 선언부에는 '메서드의 이름'과 '매게변수 선언', '반환 타입'으로 이루어져 있다.
  + 반환값이 없는 경우 반환타입으로 'void'를 적어야 한다.
  + 반환값이 있는 경우 반환값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.
 
+ 3.5 메서드의 호출
  + 메서드를 호출할 때 괄호()안에 지정해준 값들을 '인자(argument)'라고 하고, 인자의 개수와 순서는 호출된 메서드에 선언된 매게변수(parameter)와 일치해야 한다.
 
+ 3.6 return문
  + return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 모든 메서드에는 적어도 하나의 return문이 있어야 한다.반환타입이 void인 경우 컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해준다.

+ 3.7 JVM의 메모리 구조
  + 1. 메서드 영역 - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 분석호가 클래스에 대한 정보를 메서드 영역에 저장한다. 클래스 변수들이 생성되는 공간이다.
  + 2. 힙 - 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 인스턴수 변수들이 생성되는 공간이다.
  + 3. 호출스택 - 메서드의 작업에 필요한 메모리 공간을 제공한다.
    + 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    + 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    + 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
    + 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
   
+ 3.8 기본형 매개변수와 참조형 매개변수
  + 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다. 매개변수의 타입이 기본형일 때는 기본형 값이 복사되고, 참조형일 때는 인스턴스의 주소가 복사된다.
  + 매개변수가 기본형일 때는 단순히 저장된 값을 얻어오지만, 참조형일 경우 주소를 알 수 있기 때문에 값을 읽고, 변경할 수 있다.

+ 3.11 클래스 메서드(static 메서드)와 인스턴스 메서드
  + 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
  + 인스턴스와 관계없는 메서드를 클래스 메서드로 정의한다.
  + 1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
    2. 클래스 변수(static)는 인스턴스를 생성하지 않아도 사용할 수 있다.
    3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
    4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. - 성능이 향상됨

+ 3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출
  + 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하기 때문에 인스턴스 멤버는 클래스 멤버를 호출할 수 있지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수 있기 때문에 클래스 멤버는 인스턴스 멤버를 호출할 수 없다.
 
## 4. 오버로딩(overloading)

+ 4.1 오버로딩이란?
  + 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩'이라고 한다.
 
+ 4.2 오버로딩의 조건
  + 1. 메서드 이름이 같아야 한다.
    2. 매개변수의 개수 또는 타입이 달라야 한다.
  + 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
 
+ 4.4 오버로딩의 장점
  + 메서드의 이름을 기억하기 쉽고 효율적으로 사용할 수 있으며, 메서드의 이름만 보고 메서드의 기능을 예측할 수 있게 한다.
 
+ 4.5 가변인자(varargs)와 오버로딩
  + 메서드의 매개변수 개수를 고정적이지 않고 동적으로 지정할 수 있게 해준다.
    ```
    타입... 변수명
    ```
  + 위와 같은 형식으로 사용된다.
 

  ## 5.생성자(constructor)

  + 5.1 생성자란?
    + 생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.
    + 생성자의 조건
    + 1. 생성자의 이름은 클래스의 이름과 같아야 한다.
      2. 생성자는 return 값이 없다.
    + 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아니다.
    ```
    Card c = new Card();
    1. 연산자 new에 의해서 메모리에 Card클래스의 인스턴스가 생성된다.
    2. 생성자 Card()가 호출되어 수행된다.
    3. 연산자 new의 결과로 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
    ```

  + 5.2 기본 생성자(default constructor)
    + 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.
    + 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 '기본 생성자'가 있기 때문이다.
    + 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

  + 5.4 생성자에서 다른 생성자 호출하기 -this(), this
    + 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
    + 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.


  ## 6. 변수의 초기화

  + 6.1 변수의 초기화
    + 변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다.
    + 멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지지만, 지역변수는 사용하기 전에 반드시 초기화해야한다.
    + 멤버변수의 초기화 방법
      1. 명시적 초기화
      2. 생성자
      3. 초기화 블럭

  + 6.2 명시적 초기화
    + 변수를 선언과 동시에 초기화 하는 것을 명시적 초기화라고 한다.
    ```
    clasee Car{
      int door = 4; // 기본형 변수의 초기화
      Engine e= new Engine(); // 참조형 변수의 초기화
    ```

  + 6.3 초기화 블럭
    + 클래스 초기화 블럭 - 클래스 변수의 복잡한 초기화에 사용된다.
    + 인스턴스 초기화 블럭 - 인스턴스 변수의 복잡한 초기화에 사용된다.
    ```
    class InitBlock{
      static { /* 클래스 초기화 블럭 */}
      { /*인스턴스 초기화 블럭 */}
    ```
    + 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다.
    + 클래스의 모든 생성자에서 공통으로 수행되어야 하는 문장들이 있을 때 인스턴스 블럭에 넣어주면 코드가 간결해진다.

  + 6.4 멤버변수의 초기화 시기와 순서
    + 클래스 변수의 초기화 시점 - 클래스가 처음 로딩될 때 단 한번 초기화 된다.
    + 인스턴스 변수의 초기화 시점 - 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.
    + 클래스 변수의 초기화 순서 - 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
    + 인스턴스 변수의 초기화 순서 - 기본값 ->명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자
