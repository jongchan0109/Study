# 12 지네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

+ 1.1 지네릭스란?
  + 지네릭스는 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능이다.
  + 지네릭스의 장점
  + List: 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
    1. 타입 안정성을 제공한다.
    2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
  
+ 1.2 지네릭 클래스의 선언
  + 클래스를 지네릭 클래스로 변경하면 클래스 옆에 '<T>'를 붙이고, 'Object'를 모두 'T'로 바꾼다.
  + '<T>'에서 T를 타입변수라고 하며, Type의 첫 글자에서 따온 것이다.
  + 타입변수를 무조건 'T'를 사용하기보다 가능하면, 상황에 맞게 의미있는 문자를 선택해서 사용하는 것이 좋다.
  + 지네릭이 도입되기 이전의 코드와 호환을 위해, 지네릭 클래스인데도 예전의 방식으로 객체를 생성하는 것이 허용된다.
  + class Box<T> {}
    1. Box<T> : 지네릭 클래스. 'T의 Box'또는 'T Box'라고 읽는다.
    2. T : 타입 변수 또는 타입 매개변수.(T는 타입 문자)
    3. Box : 원시 타입(raw type)
  + Box<String>와 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 이 둘이 별개의 클래스를 의미하는 것은 아니다.
  + 모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수는 없다. static멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다.
  + 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. new연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다.
  
+ 1.3 지네릭 클래스의 객체 생성과 사용
  + Box<T>의 객체를 생성할 때는 다음과 같이 한다.
  ```
  Box<Apple> appleBox = new Box<Apple>();
  Box<Apple> appleBox = new Box<Grape>(); // 에러
  ```
  + 참조변수와 생성자에 대입된 타입이 일치해야 한다.
  + JDK1.7부터는 추정이 가능한 경우 타입을 생략할 수 있게 되었다.
  
+ 1.4 제한된 지네릭 클래스
  + 타입 문자로 사용할 타입을 명시하면 한 종류의 타입만을 저장할 수 있도록 제한할 수 있지만, 그래도 여전히 모든 종류의 타입을 지정할 수 있다는 것에는 변함이 없다.
  + 지네릭 타입에 'extends'를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
  + 여전히 한 종류의 타입만 담을 수 있지만, 특정 클래스의 자손들만 담을 수 있다는 제한이 더 추가된 것이다.
  + 만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이때도 'extends'를 사용한다.
  + 특정 클래스의 자손이면서 특정 인터페이스도 구현해야 한다면 '&'기호로 연결한다.
   
+ 1.5 와일드 카드
  + static 메소드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로, 타입 매개변수 대신 특정 타입을 지정해줘야 한다.
  + 지네릭 타입을 고정해놓으면, 여러 가지 타입의 매개변수를 갖는 메소드들을 각각 만들 수 밖에 없는데, 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문에 컴파일 에러가 발생한다.
  + 이럴 때 사용하기 위해 고안된 것이 바로 '와일드 카드'이다.
    1. <? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
    2. <? super T> : 와일드 카드의 제한. T와 그 조상들만 가능
    3. <?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
  
+ 1.6 지네릭 메소드
  + 메소드의 선언부에 지네릭 타입이 선언된 메소드를 지네릭 메소드라 한다. 지네릭 타입의 선언 위치는 반환 타입 바로 앞이다.
  + 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메소드에 정의된 타입 매개변수는 전혀 별개의 것이다.
  + 메소드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 이해하기 쉬운데, 이 타입 매개변수는 메소드 내에서만 지역적으로 사용될 것이므로 메소드가 static이건 아니건 상관이 없다.
 
+ 1.7 지네릭 타입의 형변환
  + 지네릭 타입과 넌지네릭(non-generic)타입간의 형변환은 항상 가능하다. 다만 경고가 발생할 뿐이다.
  + 대입된 타입이 다른 지네릭 타입 간에는 형변환이 불가능하다.

+ 1.8 HashSet
  + HashSet은 Set인터페이스를 구현한 가장 대표적인 컬렉션이며, Set인터페이스의 특징대로 HashSet은 중복된 요소를 저장하지 않는다.
  + HashSet에 새로윤 요소를 추가할 때는 add메소드나 addAll메소드를 사용하는데, 만일 HashSet에 이미 저장되어 있는 요소와 중복된 요소를 추가하고자 한다면 이 메소드들은 false를 반환함으로써 중복된 요소이기 때문에 추가에 실패했다는 것을 알린다.
  + Set을 구현한 컬렉션 클래스는 List를 구현한 컬렉션 클래스와 달리 순서를 유지하지 않기 때문에 저장한 순서와 다를 수 있다.
  + 만일 중복을 제거하는 동시에 저장한 순서를 유지하고자 한다면 HashSet 대신 LinkedHashSet을 사용해야 한다.
  + HashSet의 add메소드는 새로윤 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기 때문에 equals()와 hashCode()를 목적에 맞게 오버라이딩해야 한다.
  + 오버라이딩을 통해 작성된 HashCode()는 다음의 세 가지 조건을 만족 시켜야 한다.
    1. 실행 중인 애플리케이션 내의 동일한 객체에 대해서 여러번 hashCode()를 호출해도 동일한 int값을 반환해야 한다. 하지만, 실행시마다 동일한 int값을 반환할 필요는 없다.
    2. equals메소드를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야 한다.
    3. equals메소드를 호출했을 때 false를 반환하는 두 객체는 hashCode() 호출에 대해 같은 int값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int값을 반환하는 것이 좋다.
   
+ 1.9 TreeSet
  + TreeSet은 이진 검색 트리라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스이다.
  + Set인터페이스를 구현했으므로 중복된 데이터의 저장을 허용하지 않으며, 정렬된 위치에 저장하므로 저장순서를 유지하지도 않는다.
  + TreeSet에 저장되는 객체가 Comparable을 구현하던가 아니면, TreeSet에게 Comparator를 제공해서 두 객체를 비교할 방법을 알려줘야 한다.
  + 이진 검색 트리(Binary Search Tree)
    1. 모든 노드는 최대 두개의 자식노드를 가질 수 있다.
    2. 왼쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽 자식노드의 값은 부모노드의 값보다 커야한다.
    3. 노드의 추가 삭제에 시간이 걸린다.(순차적으로 저장하지 않으므로)
    4. 검색(범위검색)과 정렬에 유리하다.
    5. 중복된 값을 저장하지 못한다.

+ 1.10 HashMap과 Hashtable
  + HashMap은 Hashtable의 새로운 버전이다.
  + HashMap은 Map을 구현했으므로 Map의 특징, 키와 값을 묶어서 하나의 데이터로 저장한다는 특징을 갖는다. 그리고 해싱을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뒤어난 성능을 보인다.
  + hashMap은 키와 값을 각각 Object타입으로 저장한다. 그렇지만 키는 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 한다.
  + 키는 저장된 값을 찾는데 사용되는 것이기 때문에 컬랙션 내에서 유일해야 한다.
  + 해싱과 해시함수
    + 해싱이란 해시함수(hash function)를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법을 말한다.
    + 해시함수는 데이터가 저장되어 있는 곳을 알려 주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.
    + 해싱을 구현하는 과정에서 제일 중요한 것은 해시함수의 알고리즘이다.
    + 실제로는 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 Object클래스에 정의된 hashCode()를 해시함수로 사용한다.
    + Object클래스에 정의된 hashCode()는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 hashCode()를 호출한 결과가 서로 유일한 훌륭한 방법이다.

+ 1.11 TreeMap
  + TreeMap은 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다. 그래서 검색과 정렬에 적합한 컬렉션 클래스이다.
  + 검색에 관한 대부분의 경우에서 HashMap이 TreeMap보다 더 뛰어나므로 HashMap을 사용하는 것이 좋다. 다만 범위검색이나 정렬이 필요한 경우에는 TreeMap이 더 좋다.

+ 1.12 Properties
  + Properties는 HashMap의 구버전인 Hashtable을 상속받아 구현한 것으로, Hashtable은 키와 값을 (Object,Object)의 형태로 저장하는데 비해 Properties는 (String, String)의 형태로 저장하는 보다 단순화된 컬렉션클래스이다.
  + 주로 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.

+ 1.13 Collections
  + Arrays가 배열과 관련된 메소드를 제공하는 것처럼, Collections는 컬렉션과 관련된 메소드를 제공한다.
  + 멀티 쓰레드는 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성을 유지하기 위해서는 공유되는 객체에 동기화가 필요하다.
  + ArrayList와 HashMap과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 java.util.Collections클래스의 동기화 메소드를 이용해서 동기화처리가 가능하도록 변경하였다.
  + 컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게, 즉 읽기전용으로 만들수 있는 기능을 제공한다.
  + 단 하나의 객체만을 저장하는 컬렉션을 만들고 싶을 때 singleton메소드를 이용하여 만들 수 있다.
  + 한 종류의 객체만 저장하는 컬렉션을 만들 수 있다.
    
