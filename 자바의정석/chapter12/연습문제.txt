[12-1] 클래스 Box가 다음과 같이 정의되어 있을 때, 다음 중 오류가 발생하는 문장은? 경고가 발생하는 문장은?

class Box<T>{
  T item;

  void setItem(T item){this.item = item;}
  T getItem() {return item;}
}

a. Box<Object> b = new Box<String>();
b. Box<Object> b = (Object)new Box<String>();
c. new Box<String>().setItem(new Object());
d. new Box<String>().setItem("ABC");

[12-1 풀이]
a. Box<Object> b = new Box<String>(); // 대입된 타입이 반드시 같아야 한다.
b. Box<Object> b = (Object)new Box<String>(); // Object타입의 인스턴스를 Box<Object>참조변수에 저장 불가
c. new Box<String>().setItem(new Object()); // 대입된 타입이 String이므로, setItem(T item)의 매개변수 역시, String타입만 허용된다.


[12-2] 지네릭 메소드 makeJuice()가 아래와 같이 정의되어 있을 때, 이 메소드를 올바르게 호출한 문장을 모두 고르시오.(Apple과 Grape는 Fruit의 자손이라고 가정하자.)

class Juicer{
  static <T extends Fruit> String MakeJuice(FruitBox<T> box){
    String tmp = "":
    for(Fruit f: box.getList()) tmp += f+" ';
    return tmp;
  }
}

a. Juicer.<Apple>makeJuice(new FruitBox<Fruit>());
b. Juicer.<Fruit>makeJuice(new FruitBox<Grape>());
c. Juicer.<Fruit>makeJuice(new FruitBox<Fruit>());
d. Juicer.makeJuice(new FruitBox<Apple>());
e. Juicer.makeJuice(new FruitBox<Object>());

[12-2 풀이]
c. Juicer.<Fruit>makeJuice(new FruitBox<Fruit>());
d. Juicer.makeJuice(new FruitBox<Apple>());


[12-3] 다음 중 올바르지 않은 문장을 모두 고르시오.

class Box<T extends Fruit>{
  T item;

  void setItem(T item) {this.item = item;}
  T getItem() {return item;}
}
