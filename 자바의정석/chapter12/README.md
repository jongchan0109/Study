# 12 지네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

+ 1.1 지네릭스란?
  + 지네릭스는 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능이다.
  + 지네릭스의 장점
  + List: 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
    1. 타입 안정성을 제공한다.
    2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
  
+ 1.2 지네릭 클래스의 선언
  + 클래스를 지네릭 클래스로 변경하면 클래스 옆에 '<T>'를 붙이고, 'Object'를 모두 'T'로 바꾼다.
  + '<T>'에서 T를 타입변수라고 하며, Type의 첫 글자에서 따온 것이다.
  + 타입변수를 무조건 'T'를 사용하기보다 가능하면, 상황에 맞게 의미있는 문자를 선택해서 사용하는 것이 좋다.
  + 지네릭이 도입되기 이전의 코드와 호환을 위해, 지네릭 클래스인데도 예전의 방식으로 객체를 생성하는 것이 허용된다.
  + class Box<T> {}
    1. Box<T> : 지네릭 클래스. 'T의 Box'또는 'T Box'라고 읽는다.
    2. T : 타입 변수 또는 타입 매개변수.(T는 타입 문자)
    3. Box : 원시 타입(raw type)
  + Box<String>와 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 이 둘이 별개의 클래스를 의미하는 것은 아니다.
  + 모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수는 없다. static멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다.
  + 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. new연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다.
  
+ 1.3 지네릭 클래스의 객체 생성과 사용
  + Box<T>의 객체를 생성할 때는 다음과 같이 한다.
  ```
  Box<Apple> appleBox = new Box<Apple>();
  Box<Apple> appleBox = new Box<Grape>(); // 에러
  ```
  + 참조변수와 생성자에 대입된 타입이 일치해야 한다.
  + JDK1.7부터는 추정이 가능한 경우 타입을 생략할 수 있게 되었다.
  
+ 1.4 제한된 지네릭 클래스
  + 타입 문자로 사용할 타입을 명시하면 한 종류의 타입만을 저장할 수 있도록 제한할 수 있지만, 그래도 여전히 모든 종류의 타입을 지정할 수 있다는 것에는 변함이 없다.
  + 지네릭 타입에 'extends'를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
  + 여전히 한 종류의 타입만 담을 수 있지만, 특정 클래스의 자손들만 담을 수 있다는 제한이 더 추가된 것이다.
  + 만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이때도 'extends'를 사용한다.
  + 특정 클래스의 자손이면서 특정 인터페이스도 구현해야 한다면 '&'기호로 연결한다.
   
+ 1.5 와일드 카드
  + static 메소드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로, 타입 매개변수 대신 특정 타입을 지정해줘야 한다.
  + 지네릭 타입을 고정해놓으면, 여러 가지 타입의 매개변수를 갖는 메소드들을 각각 만들 수 밖에 없는데, 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문에 컴파일 에러가 발생한다.
  + 이럴 때 사용하기 위해 고안된 것이 바로 '와일드 카드'이다.
    1. <? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
    2. <? super T> : 와일드 카드의 제한. T와 그 조상들만 가능
    3. <?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
  
+ 1.6 지네릭 메소드
  + 메소드의 선언부에 지네릭 타입이 선언된 메소드를 지네릭 메소드라 한다. 지네릭 타입의 선언 위치는 반환 타입 바로 앞이다.
  + 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메소드에 정의된 타입 매개변수는 전혀 별개의 것이다.
  + 메소드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 이해하기 쉬운데, 이 타입 매개변수는 메소드 내에서만 지역적으로 사용될 것이므로 메소드가 static이건 아니건 상관이 없다.
 
+ 1.7 지네릭 타입의 형변환
  + 지네릭 타입과 넌지네릭(non-generic)타입간의 형변환은 항상 가능하다. 다만 경고가 발생할 뿐이다.
  + 대입된 타입이 다른 지네릭 타입 간에는 형변환이 불가능하다.
  + 와일드 카드를 이용한 타입 매개변수 선언의 경우에는 형변환이 가능하다.

+ 1.8 지네릭 타입의 제거
  + 컴파일러는 지네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에 형변환을 넣어준다. 그리고 지네릭 타입을 제거한다. 즉, 컴파일된 파일에는 지네릭 타입에 대한 정보가 없는 것이다.
  + 1. 지네릭 타입의 경계(bound)를 제거한다.
    2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가한다.
   
## 2. 열거형(enums)
+ 2.1 열거형이란?
  + 열거형은 서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용하다.
  ```
  class Card{
    enum Kind {CLOVER, HEART, DIAMOND, SPADE}
    enum Value {TWO, THREE, FOUR}

    final Kind kind;
    final Value value;
  }
  ```
  + 기존의 많은 언어들, 예를 들면 C언어에서는 타입이 달라도 값이 같으면 조건식 결과가 참이였으나, 자바의 열거형은 '타입에 안전한 열거형'이라거 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다.
  + 상수의 값이 바뀌면, 해당 상수를 참조하는 모든 소스를 다시 컴파일해야 한다. 하지만 열거형 상수를 사용하면, 기존의 소스를 다시 컴파일하지 않아도 된다.

+ 2.2 열거형의 정의와 사용
  + 열거형을 정의하는 방법은 간단하다. 다음과 같이 괄호{}안에 상수의 이름을 나열하기만 하면 된다.
  ```
  enum 열거형이름 {상수명1, 상수명2, ...}
  ```
  + 이 열거형에 정의된 상수를 사용하는 방법은 '열거형이름.상수명'이다.
  + 열거형 상수간의 비교에는 '=='를 사용할 수 있다. equlas()가 아닌 '=='로 비교가 가능하다는 것은 그만큼 빠른 성능을 제공한다는 얘기다. 그러나 '<','>'와 같은 비교연산자는 사용할 수 없고 compareTo()는 사용가능하다.
  + switch문의 조건식에도 열거형을 사용할 수 있고, case문에 열거형의 이름은 적지 않고 상수의 이름만 적어야 한다는 제약이 있다.
  + java.lang.Enum은 모든 열거형의 조상이다.
  + 열거형 Direction에 정의된 모든 상수를 출력하려면, 다음과 같이 한다.
  ```
  Direction[] dArr = Direction.values();
  for(Direction d:dArr)
    System.out.printf("%s=%d%n",d.name(),d.ordinal());
  ```
  + values()는 열거형의 모든 상수를 배열에 담아 반환한다. 이 메소드는 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 추가해 준다.

+ 2.3 열거형에 멤버 추가하기
  + Enum클래스에 정의된 ordinal()이 열거형 상수가 정의된 순서를 반환하지만, 이 값을 열거형 상수의 값으로 사용하지 않는 것이 좋다. 이 값은 내부적인 용도로만 사용되기 위한 것이기 때문이다.
  + 열겨형 상수의 값이 불연속적인 경우에는 열거형 상수의 이름 옆에 원하는 값을 괄호()와 함께 적어주면 된다.
  + 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자롤 새로 추가해 주어야 한다.
  ```
  enum Direction{
    EAST(1), SOUTH(5), WEST(-1), NORTH(10);
    private final int value;
    Direction(int value) {this.value = value;}
    public int getValue() {return value;}
  ```
  + 열거형 Direction에 새로운 생성자가 추가되었지만, 열거형의 객체를 생성할 수 없다. 열거형의 생성자는 제어자가 묵시적으로 private이기 때문이다.
  + 필요하다면, 하나의 열거형 상수에 여러 값을 지정할 수도 있다. 다만 그에 맞게 인스턴스 변수와 생성자 등을 새로 추가해주어야 한다.
  + 열거형에 추상 메소드를 선언하면 각 열거형 상수가 이 추상 메소드를 반드시 구현해야 한다.

## 3. 애너테이션(annotation)
+ 3.1 애너테이션이란?
  + 애너테이션이란 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이다.
  + 애너테이션은 JDK에서 기본적으로 제공하는 것과 다른 프로그램에서 제공하는 것들이 있는데, 어느 것이든 그저 약속된 형식으로 정보를 제공하기만 하면 될 뿐이다.
  + JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다. 그리고 새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션을 제공한다.

+ 3.2 표준 애너테이션
  + @Override
    + 메소드 앞에만 붙일 수 있는 애터네이션으로, 조상의 메소드를 오버라이딩하는 것이라는걸 컴파일러에게 알려주는 역할을 한다.
    + 오버라이딩할 때는 메소드의 이름을 잘못 적는 경우가 많은데, 컴파일러는 그저 새로운 이름의 메소드가 추가된 것으로 인식할 뿐이다.
    + 그러나 @Override를 붙이면, 컴파일러가 같은 이름의 메소드가 조상에 있는지 확인하고 없으면, 에러메시지를 출력한다.
  + @Deprecated
    + 새로운 버전의 JDK가 소개될 때, 새로운 기능이 추가될 뿐만 아니라 기존의 부족했던 기능들을 개선하기도 한다. 이 과정에서 기존의 기능을 대체할 것들이 추가되어도, 이미 여러 곳에서 사용되고 있을지 모르는 기존의 것들을 함부로 삭제할 수 없다.
    + 그래서 생각해낸 방법이 더 이상 사용되지 않는 필드나 메소드에 @Depreacted를 붙이는 것이다.
  + @FunctionalInterface
    + 함수형 인터페이스를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생시킨다.
  + @SuppressWarnings
    + 컴파일러가 보여주는 경고 메시지가 나타나지 않게 억제해준다.
    + 컴파일러의 경고 메시지는 무시하고 넘어갈 수도 있지만, 모두 확인하고 해결해서 컴파일 후에 어떠한 메시지도 나타나지 않게 해야 한다.
    + 경우에 따라서는 경고가 발생할 것을 알면서도 묵인해야 할 때가 있는데, 이 때 @SuppressWarnings를 사용한다.
  + @SafeVarargs
    + 메소드에 선언된 가변인자의 타입이 non-reifiable(컴파일 후에 제거되는 타입)일 경우, 해당 메소드를 선언하는 부분과 호출하는 부분에서 "unchecked"경고가 발생한다.
    + 해당 코드에 문제가 없다면 이 경고를 억제하기 위해 @SafeVarargs를 사용해야 한다.
    + 이 애너테이션은 static이나 final이 붙은 메소드와 생성자에만 붙일 수 있다. 즉, 오버라이딩될 수 있는 메소드에는 사용할 수 없다는 뜻이다.
