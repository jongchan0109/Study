# 7. 객체지향 프로그래밍2

## 1. 상속(inheritance)

+ 1.1 상속의 정의와 장점
  + 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
  + 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드의 추가 및 변경이 매우 용이하다.
  ```
    class Child extends Parent{
      //~~~
     }
  ```
  + 조상 클래스 - 부모믈래스, 상위클래스, 기반클래스
  + 자손 클래스 - 자식클래스, 하위클래스, 파생된클래스
  + 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
  + 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
    
+ 1.2 클래스간의 관계 - 포함관계
  + 클래스 내에 다른 클래스를 멤버변수로 선언하여 간결하고 손쉽게 클래스를 작성할 수 있다.
 
+ 1.3 클래스간의 관계 결정하기
  + '~은 ~이다' - 상속관계
  + '~은 ~을 가지고 있다.' - 포함관계
 
+ 1.4 단일 상속(single inheritance)
  + 다른 객체지향언어인 C++에서는 여러 조상클래스로부터 상속받는 것인 다중 상속을 지원하지만, 자바에서는 단일 상속만을 허용한다.
 
+ 1.5 Object클래스 - 모든 클래스의 조상
  + Object클래스는 모든 클래스의 조상클래스로 상속을 정의하지 않아도 컴파일러에 의해 자동적으로 상속된다.
  + 모든 클래스들은 Object클래스의 자손이므로 Object클래스에 정의된 메소드들을 사용할 수 있다.
      
## 2. 오버라이딩(overriding)

+ 2.1 오버라이딩이란?
  + 조상 클래스로부터 상속받은 메소드의 내용을 변경하는 것을 오버라이딩이라고 한다.

+ 2.2 오버라이딩의 조건
  + 자손 클래스에서 오버라이딩하는 메소드는 조상 클래스의 메소드와 이름,매개변수,반환타입이 같아야 한다.
    1. 접근 제어자는 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.
    2. 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.
    3. 인스턴스메소드를 static메소드로 또는 그 반대로 변경할 수 없다.

+ 2.3 오버로딩 vs 오버라이딩
  + 오버로딩(overloading): 기존에 없는 새로운 메소드를 정의하는 것
  + 오버라이딩(overriding): 상속받은 메소드의 내용을 변경하는 것

+ 2.4 super
  + super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
  + 조상 클래스에 선언된 멤버변수와 같은 이름의 멤버변수를 자손 클래스에서 중복해서 정의하는 것이 가능하며 참조변수 super를 이용해서 서로 구별할 수 있다.

+ 2.5 super() - 조상 클래스의 생성자
  + super()는 조상 클래스의 생성자를 호출하는데 사용된다.
  + 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야 하는데, 그 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.
  + 생성자에 첫 줄에 생성자 this()또는 super()를 호출하지 않으면 컴파일러가 자동으로 super()를 생성자의 첫 줄에 삽입한다.


## 3. package와 import

+ 3.1 패키지(package)
  + 패키지란, 클래스의 묶음으로, 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있게 한다.

+ 3.2 패키지의 선언
  ```
  package 패키지명;
  ```
  + 위와 같이 클래스나 인터페이스의 소스파일의 맨 위에 다음과 같이 한줄만 적어주면 선언할 수 있다.
  + 모든 클래스는 반드시 하나의 패키지에 포함되어야 한다.
  + 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으러 이름없는 패키지에 속하게 된다.

+ 3.3 import문
  + 소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다.
  + 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지명은 생략할 수 있다.
        
+ 3.4 import문의 선언
  + 일반적인 소스파읠의 구성은 다음의 순서로 되어 있다.
    1. package문
    2. import문
    3. 클래스 선언
  + 클래스이름을 지정해주는 대신 '*'을 사용하면, 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용할 수 있다. - 클래스 이름을 지정하는 것과 실행 시 성능상의 차이는 전혀 없다.
 
+ 3.5 static import문
  + import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이 static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

 
## 4. 오버로등(overloading)

+ 4.1 오버로딩이란?
  + 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩'이라고 한다.
 
+ 4.2 오버로딩의 조건
  + 1. 메서드 이름이 같아야 한다.
    2. 매개변수의 개수 또는 타입이 달라야 한다.
  + 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
 
+ 4.4 오버로딩의 장점
  + 메서드의 이름을 기억하기 쉽고 효율적으로 사용할 수 있으며, 메서드의 이름만 보고 메서드의 기능을 예측할 수 있게 한다.
 
+ 4.5 가변인자(varargs)와 오버로딩
  + 메서드의 매개변수 개수를 고정적이지 않고 동적으로 지정할 수 있게 해준다.
    ```
    타입... 변수명
    ```
  + 위와 같은 형식으로 사용된다.
 

  ## 5.생성자(constructor)

  + 5.1 생성자란?
    + 생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.
    + 생성자의 조건
    + 1. 생성자의 이름은 클래스의 이름과 같아야 한다.
      2. 생성자는 return 값이 없다.
    + 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아니다.
    ```
    Card c = new Card();
    1. 연산자 new에 의해서 메모리에 Card클래스의 인스턴스가 생성된다.
    2. 생성자 Card()가 호출되어 수행된다.
    3. 연산자 new의 결과로 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
    ```

  + 5.2 기본 생성자(default constructor)
    + 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.
    + 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 '기본 생성자'가 있기 때문이다.
    + 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

  + 5.4 생성자에서 다른 생성자 호출하기 -this(), this
    + 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
    + 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.


  ## 6. 변수의 초기화

  + 6.1 변수의 초기화
    + 변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다.
    + 멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지지만, 지역변수는 사용하기 전에 반드시 초기화해야한다.
    + 멤버변수의 초기화 방법
      1. 명시적 초기화
      2. 생성자
      3. 초기화 블럭

  + 6.2 명시적 초기화
    + 변수를 선언과 동시에 초기화 하는 것을 명시적 초기화라고 한다.
    ```
    clasee Car{
      int door = 4; // 기본형 변수의 초기화
      Engine e= new Engine(); // 참조형 변수의 초기화
    ```

  + 6.3 초기화 블럭
    + 클래스 초기화 블럭 - 클래스 변수의 복잡한 초기화에 사용된다.
    + 인스턴스 초기화 블럭 - 인스턴스 변수의 복잡한 초기화에 사용된다.
    ```
    class InitBlock{
      static { /* 클래스 초기화 블럭 */}
      { /*인스턴스 초기화 블럭 */}
    ```
    + 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다.
    + 클래스의 모든 생성자에서 공통으로 수행되어야 하는 문장들이 있을 때 인스턴스 블럭에 넣어주면 코드가 간결해진다.

  + 6.4 멤버변수의 초기화 시기와 순서
    + 클래스 변수의 초기화 시점 - 클래스가 처음 로딩될 때 단 한번 초기화 된다.
    + 인스턴스 변수의 초기화 시점 - 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.
    + 클래스 변수의 초기화 순서 - 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
    + 인스턴스 변수의 초기화 순서 - 기본값 ->명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자
