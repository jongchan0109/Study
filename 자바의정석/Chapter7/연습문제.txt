[7-1] 섯다카드 20장을 포함하는 섯다카드 한 벌(SutdDeck 클래스)을 정의한 것이다. 섯다카드 20장을 담는 SutdaCard배열을 초기화하시오. 
단, 섯다카드는 1부터 10까지의 숫자가 적힌 카드가 한 쌍씩 있고, 숫자가 1, 3, 8인 경우에는 둘 중의 한 장의 광(Kwang)이 있어야 한다.
즉 SutdaCard의 인스턴스 변수 isKwang의 값이 true이어야 한다.

class SutdaDeck {
    final int CARD_NUM = 20;
    SutdaCard[] cards = new SutdaCard[CARD_NUM];
    SutdaDeck() {
        /*
        (1) SutdaCard . 배열 를 적절히 초기화 하시오
        */
    }
}
class SutdaCard {
    int num;
    boolean isKwang;
    SutdaCard() {
        this(1, true);
    }
    SutdaCard(int num, boolean isKwang) {
        this.num = num;
        this.isKwang = isKwang;
    }
    // info()대신 Object 클래스이  toString()을 오버라이딩했다.
    public String toString() {
        return num + ( isKwang ? "K":"");
    }
}
class Exercise7_1 {
    public static void main(String args[]) {
        SutdaDeck deck = new SutdaDeck();
        for(int i=0; i < deck.cards.length;i++)
            System.out.print(deck.cards[i]+",");
    }
}

실행 결과
1K,2,3K,4,5,6,7,8K,9,10,1,2,3,4,5,6,7,8,9,10,

[7-1 풀이]
코드 참조


[7-2] 문제 7-1의 SutdaDeck클래스에 다음에 정의된 새로운 메소드를 추가하고 테스트 하시오.
1. 메소드명 : shuffle
   기   능 : 배열 cards에 담긴 카드의 위치를 뒤섞는다.(Math.random() 사옹)
   반환타입 : 없음
   매개변수 : 없음

2. 메소드명 : pick
   기   능 : 배열 cards에서 지정된 위치의 SutdaCard를 반환한다.
   반환타입 : SutdaCard
   매개변수 : int index - 위치

3. 메소드명 : pick
   기   능 : 배열 cards에서 임의의 위치의 SutdaCard를 반환한다.
   반환타입 : SutdaCard
   매개변수 : 없음

[7-2 풀이]
코드 참조


[7-3] 오버라이딩의 정의와 필요성에 대해서 설명하시오.

[7-3 풀이]
오버라이딩이란 조상 클래스로부터 상속받은 메소드를 자손 클래스에 맞게 재정의 하는 것이다.
조상 클래스로부터 상속받은 메소드를 자손 클래스에서 그대로 사용할 수 없는 경우가 많기 때문에 오버라이딩이 필요하다.


[7-4] 다음 중 오버라이딩의 조건으로 옳지 않은 것은?(모두 고르시오)
a. 조상의 메서드와 이름이 같아야 한다.
b. 매개변수의 수와 타입이 모두 같아야 한다.
c. 접근 제어자는 조상의 메서드보다 좁은 범위로만 변경할 수 있다.
d. 조상의 메서드보다 더 많은 수의 예외를 선언할 수 있다.

[7-4 풀이]
c. 접근 제어자는 조상의 메소드보다 넓거나 같은 범위로만 변경할 수 있다.
d. 조상의 메소드보다 더 많은 수의 예외를 선언할 수 없다.


[7-5] 다음의 코드는 컴파일하면 에러가 발생한다. 그 이유를 설명하고 에러를 수정하기 위해서는 코드를 어떻게 바꾸어야 하는가?
class Product
{
    int price; // 제품의 가격
    int bonusPoint; // 제품구매 시 제공하는 보너스점수
    Product(int price) {
        this.price = price;
        bonusPoint =(int)(price/10.0);
    }
}
class Tv extends Product {
    Tv() {}
    public String toString() {
        return "Tv";
    }
}
class Exercise7_5 {
    public static void main(String[] args) {
        Tv t = new Tv();
    }
}

[7-5 풀이]
자손 클래스의 생성자 Tv() 에서 부모클래스의 생성자를 지정하지 않아서 자동적으로 super()이 삽입이 되는데, 부모클래스에서는 매개변수가 없는 생성자가 없어서 컴파일 에러가 발생한다.
에러를 수정하기 위해서는 부모클래스에 기본 생성자를 만들거나 자손 클래스의 생성자에서 super(int price)를 첫 줄에 삽입해야 한다.


[7-6] 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출해야 하는 이유는 무엇인가?

[7-6 풀이]
자손 클래스에서는 조상 클래스의 멤버변수를 사용할 수 있는데, 조상 클래스의 멤버변수가 초기화 되지 않고 사용되면 에러가 발생할 수 있기 때문이다.


[7-7] 다음 코드의 실행했을 때 호출되는 생성자의 순서와 실행결과를 적으시오.
class Parent {
    int x=100;
    Parent() {
        this(200);
    }
    Parent(int x) {
        this.x = x;
    }
    int getX() {
        return x;
    }
}
class Child extends Parent {
    int x = 3000;
    Child() {
        this(1000);
    }
    Child(int x) {
        this.x = x;
    }
}
class Exercise7_7 {
    public static void main(String[] args) {
        Child c = new Child();
        System.out.println("x="+c.getX());
    }
}

[7-7 풀이]
Child() -> Child(int x) -> Parent() -> Parent(int x) -> Object()


[7-8] 다음 중 접근제어자를 접근범위가 넓은 것에서 좁은 것의 순으로 바르게 나열한 것은?
a. public-protected-(default)-private
b. public-(default)-protected-private
c. (default)-public-protected-private
d. private-protected-(default)-public

[7-8 풀이]
a public -> protected -> (default) -> private


[7-9] 다음 중 제어자 final을 붙일 수 있는 대상과 붙였을 때 그 의미를 적은 것이다. 옳지 않은 것은? (모두 고르시오)
a. 지역변수 - 값을 변경할 수 없다.
b. 클래스 - 상속을 통해 클래스에 새로운 멤버를 추가할 수 없다.
c. 메서드 - 오버로딩을 할 수 없다.
d. 멤버변수 - 값을 변경할 수 없다.

[7-9 풀이]
c. 메소드 - 오버라이딩을 할 수 없다.


[7-10] MyTv2클래스의 멤버변수 isPowerOn, channel, volume을 클래스 외부에서 접근할 수 없도록 제어자를 붙이고, 대신
이 멤버변수들의 값을 어디서나 읽고 변경할 수 있도록 getter와 setter 메소드를 추가하라.

[7-10 풀이]
코드 참조
