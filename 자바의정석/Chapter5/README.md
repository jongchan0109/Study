# 5.배열(array)

## 1. 배열(array)

+ 1.1 배열이란?
  
  + 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 배열이라고 한다.

+ 1.2 배열의 선언과 생성
  + 배열을 선언하는 방법은 원하는 타입의 변수를 선언하고 변수 또는 타입에 배열임을 의미하는 대괄호[]를 붙이면 된다.
  + 타입[] 변수이름;
  + 타입 변수이름[];
  + 배열을 선언한 다음에는 배열을 생성해야 한다. 배열을 선언하는 것은 단지 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어질 뿐이고, 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어진다.
  + 타입[] 변수이름 = new 타입[길이];

+ 1.3 배열의 길이와 인덱스
  + 생성된 배열의 각 저장공간을 배열의 요소(elememt)라고 하며, 배열이름[인덱스]의 형식으로 접근한다.
  + 인덱스(index)는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용된다.
  + 인덱스(index)의 범위는 0부터 배열길이 -1 까지이다.
  + 배열은 index로 상수 대신 변수나 수식도 사용할 수 있다.
  + 유효하지 않은 값을 index로 사용하면 에러(ArrayIndexOutOfBoundsException)가 발생한다.
  + 배열을 생성할 때 괄호[]안에 배열의 길이를 적어줘야 하는데, 배열의 길이는 양의 정수이어야 하며 최대값은 int타입의 최대값이다.
  + 길이가 0인 배열도 생성가능하다.
  + 배열이름.length를 통해서 배열의 길이에 대한 정보를 얻을 수 있다.
  + 배열의 길이 변경하기
    1. 더 큰 배열을 새로 생성한다.
    2. 기존 배열의 내용을 새로운 배열에 복사한다.
 
+ 1.4 배열의 초기화
  + 배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화됨
  + int[] score = new int[] {50,60,70,80,90}; 의 형태로 초기화 가능 -> []안에 배열의 길이는 적지 않아도 됨
    
+ 1.5 배열의 복사
  1. for문을 이용해서 배열을 복사
  2. System.arraycopy()를 이용한 복사 -> System.arraycopy(num,0,newNum,0,num.length) -> num[0]에서 newNum[0]으로 num.length개의 데이터를 복사

      
## 2. String배열

+ 2.1 String배열의 선언과 생성
  + 배열의 타입이 String인 경우에도 다른 기본형 배열의 선언과 생성방법은 다르지 않다.

+ 2.2 String배열의 초기화
  + 배열의 타입이 String인 경우에도 다른 기본형 배열의 초기화방법은 다르지 않다.

+ 2.3 char배열과 String클래스
  + String클래스는 char배열에 기능(메서드)을 추가한 것이다.
  + String클래스의 주요 메서드
    1. char charAt(int index): 문자열에서 해당 위치(index)에 있는 문자를 반환한다.
    2. int length(): 문자열의 길이를 반환한다.
    3. String substring(int from,int to): 문자열에서 해당 범위(from~to)에 있는 문자열을 반환한다.
    4. boolean equals(Object obj): 문자열의 내용이 obj와 같은지 확인한다. 같으면 결과는 true, 다르면 false가 된다.
    5. char[] toCharArray(): 문자열을 문자배열로 변환해서 반환한다.
    
## 3. 산술 연산자
+ 산술 연산자에는 사칙 연산자(+,-,*,/)와 나머지 연산자(%)가 있다.

+ 3.1 사칙 연산자 +  -  *  /
  + 사칙 연산자는 이미 알고 있는 것처럼 곱셈(*), 나눗셈(/), 나머지(%) 연산자가 덧셈(+), 뺄셈(-) 연산자보다 우선순위가 높다.
  + 피연산자가 정수힝연 깅우, 나누는 수로 0을 사용할 수 없다.
  + byte a=10,b=20; byte c = a+b; 에서 a와 b는 모두 byte형으로 연산자 '+'는 이 두 개의 피연산자를 int형으로 변환하여 덧셈을 수행하기 때문에 컴파일 에러가 발생한다.
  + char c1 = 'a'; char c2 = c1+1; 에서 c1이 char형에서 int형으로 변환되어 덧셈이 진행되기 때문에, 명시적 형변환을 하지 않으면 컴파일 에러가 발생한다.
 
## 4 비교 연산자
+ 비교 연산자는 두 피연산자를 비교하는 데 사용되는 연산자이고, 주로 조건문과 반복문의 조건식에 사용된다.
+ 연산 결과는 true와 false이고, 이항 연산자이므로 비교하는 피연산자의 타입이 다를 경우 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다.
+ 4.1 대소비교 연산자 <  >  <=  >=
  + 두 피연산자의 값의 크기를 비교하는 연산자이고, 참이면 true, 거짓이면 false를 결과로 반환한다.
  + boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만, 참조형에는 사용할 수 없다.
+ 4.2 등가비교 연산자 == !=
  + 두 피연산자의 값이 같은지 또는 다른지 비교하는 연산자이고, 대소비교 연산자와 달리 기본형, 참조형에 모두 사용될 수 있다.
  + 기본형의 경우 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 저장하기 때문에 두 개의 피연산자가 같은 객체를 가리키고 있는지를 알 수 있다.
  + 기본형과 참조형은 서로 형변환이 가능하지 않기 때문에 등가비교 연산자로 기본형과 참조형을 비교할 수 없다.
  + 실수형은 정수형과 달리 근사값으로 저장되므로 오차가 발생할 수 있다.

## 5 논리 연산자
+ 논리 연산자는 둘 이상의 조건을 그리고(AND)와 또는(OR)으로 연결하여 하나의 식으로 표현할 수 있게 해준다.
+ 5.1 논리 연산자 &&  ||  !
  + ||(OR결합): 피연산자 중 어느 한쪽만 true이면 true를 결과로 얻는다.
  + &&(AND결합): 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.
  + !(논리 부정 연산자): 피연산자가 true이면 false를, false이면 true를 결과로 반환한다.
+ 5.2 비트 연산자 &  |  ^  ~  <<  >>
  + |(OR연산자): 피연산자 중 한쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
  + &(AND연산자): 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
  + ^(XOR연산자): 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
  + ~(비트 전환 연산자): 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다. ~로 변환을 하면 피연산자의 '1의 보수'를 얻을 수 있다.
  + << >>(쉬프트 연산자): 피연산자의 각 자리를 오른쪽, 왼쪽으로 이동하는 연산자이다.
    + << 연산자의 경우 각 자리를 왼쪽으로 이동시키며 빈칸을 0으로 채운다.
    + '>>' 연산자의 경우 부호를 유지하기 위해 피연산자가 음수인 경우 빈자리를 1로 채운다. 양수일 경우 빈자리를 0으로 채운다.
    + x << n 은 x*2^n과, x >> n은 x/2^n과 같다.

## 6 그 외의 연산자
+ 6.1 조건 연산자 ?:
  + 조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이다.
  + 조건식 ? 식1: 식2 으로 표현이 되고, 조건식의 결과가 true이면 식1을, false이면 식2를 반환한다.
+ 6.2 대입 연산자 = op=
  + 대입 연산자 =는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다.
  + 복합 대입 연산자 op=는 대입 연산과 op연산을 함께 수행하는 연산자이다.
