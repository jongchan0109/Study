# 8. 예외처리

## 1. 예외처리(exception handling)

+ 1.1 프로그램 오류
  + 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있는데, 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.
  + 컴파일 에러: 컴파일 시에 발생하는 에러
  + 런타임 에러: 실행 시에 발생하는 에러
  + 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 것
 
  + 에러(error): 프로그램 코드에 의해서 수습될 수 없는 심각한 오류(메모리 부족, 스택오버플로우 등)
  + 예외(exception): 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
      
+ 1.2 예외 클래스의 계층구조
  + 자바에서는 실행 시 발생할 수 있는 오류(exception,error)를 클래스로 정의하였다.
  + 모든 클래스의 조상은 Object클래스이므로 Exception과 Error클래스 역시 Object클래스의 자손들이다.
  + 예외 클래스들은 다음과 같이 두 그룹으로 나눠질 수 있다.
    1. Exception클래스와 그 자손들
    2. RuntimeException클래스와 그 자손들
  + RuntimeException클래스들은 주로 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.
  + Exception클래스들은 주로 외부의 영향으로 발생할 수 있는 것들로서, 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다.
 
+ 1.3 예외처리하기 - try-catch문
  + 예외처리란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이며, 예외처리의 목적은 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것이다.
  + 발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, 처리되지 못한 예외는 JVM의 '예외처리기'가 받아서 예외의 원인을 출력한다.
    ```
    try{
      // 예외가 발생할 가능성이 있는 문장들을 넣는다.
    } catch(Exception1 e1){
        //Exception1이 발생했을 경우, 이를 처리하기 위한 문장들을 넣는다.
    } catch(Exception2 e2){
        //Exception2이 발생했을 경우, 이를 처리하기 위한 문장들을 넣는다.
    } catch(ExceptionN eN){
        //ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장들을 넣는다.
    }
    ```
  + 하나의 try블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch블럭이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한개의 catch블럭만 수행된다.
 
+ 1.4 try-catch문에서의 흐름
  + try블럭 내에서 예외가 발생한 경우
    1. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
    2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.
  + try블럭 내에서 예외가 발생하지 않은 경우
    1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.
 
+ 1.5 예외의 발생과 catch블럭
  + catch블럭은 괄호()와 블럭{} 두 부분으로 나눠져 있는데, 괄호()내에서는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언해야한다.
  + 예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어지고, 첫 번째 catch블럭부터 차례로 내려가면서 catch블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스에 instanceof 연산자를 이용하여 검사하게 되는데, 검사결과가 true인 catch블럭을 만날 때까지 검사는 계속된다.
  + 모든 예외 클래스는 Exception클래스의 자손이므로, catch블럭의 괄호()에 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해서 처리된다.
  + 예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있으며, getMessage()와 printStackTrace()를 통해서 이 정보들을 얻을 수 있다.
    1. printStackTrace(): 예외발생 당시의 호출스택에 있었던 메소드의 정보와 예외 메시지를 화면에 출력한다.
    2. 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

+ 1.6 예외 발생시키기
  + 키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.
    1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다.
    2. 키워드 throw를 이용해서 예외를 발생시킨다.
  ```
  Exception e = new Exception("예외 발생");
  throw e;
  // throw new Exception("예외 발생");
  ```
  + Exception 인스턴스를 생성할 때, 생성자에 String을 넣어 주면, 이 String이 Exception 인스턴스에 메시지로 저장된다.
  + Exception 클래스들이 발생할 가능성이 있는 문장들에 대해 예외처리를 해주지 않으면 컴파일 조차 되지 않는다.
  + 컴파일러가 예외처리를 하지 않는 RuntimeException 클래스들은 'unchecked예외'라고 부르고, 예외처리를 확인하는 Exception 클래스들은 'checked예외'라고 부른다.

+ 1.7 메소드에 예외 선언하기
  + 메소드에 예외를 선언하려면, 메소드의 선언부에 키워드 throws를 사용해서 메소드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다.
  ```
  void method() throws Exception1, Exception2, ... ExceptionN{
    // 메소드의 내용
  }
  ```
  + 메소드에 예외를 선언할 때 일반적으로 RuntimeException 클래스들은 적지 않는다. 이들은 메소드 선언부의 throws에 선언한다고 해서 문제가 되지는 않지만, 보통 반드시 처리해주어야 하는 예외들만 선언한다.
  + 예외를 메소드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신을 호출한 메소드에게 예외를 전달하여 예외처리를 떠맡기는 것이다.
  + 예외를 전달받은 메소드가 또 다시 자신을 호출한 메소드에게 전달할 수 있으며, 이런 식으로 계속 호출스택에 있는 메소드들을 따라 전달되다가 제일 마지막에 있는 main메소드에서도 예외가 처리되지 않으면, main메소드마저 종료되어 프로그램이 전체가 종료된다.

+ 1.8 finally블럭
  + finally블럭은 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다. try-catch문의 끝에 선택적으로 덧붙여 사용할 수 있으며, try-catch-finally의 순서로 구성된다.
  ```
  try{
    // 예외가 발생할 가능성이 있는 문장들을 넣는다.
  } catch(Exception1 e1) {
    // 예외처리를 위한 문장을 적는다.
  } finally {
    // 예외의 발생여부에 관계없이 항상 수행되여야하는 문장들을 넣는다.
  }
  ```
  + 예외가 발생한 경우에는 'try -> catch -> finally'의 순으로 실행되고, 예외가 발생하지 않은 경우에는 'try ->finally'의 순으로 실행된다.
  + try블럭이나 catch블럭에서 return문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행된 후에, 현재 실행 중인 메소드를 종료한다.
 
+ 1.9 자동 자원 반환 - try-with-resources문
  + try-with-resuources문의 괄호()안에 객체를 생성하는 문장을 넣으면, 애 객체는 다로 close를 호출하지 않아도 try블럭을 벗어나는 순간 자동적으로 close()가 호출된다.

+ 1.10 사용자정의 예외 만들기
  + 기존의 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있다.
  + 보통 Exception클래스 또는 RuntimeException클래스로부터 상속받아 클래스를 만들지만, 필요에 따라서 알맞은 예외 클래스를 선택할 수 있다.
 
+ 1.11 예외 되던지기(exception re-throwing)
  + 한 메소드에서 발생할 수 있는 예외가 여럿인 경우, 몇 개는 try-catch문을 통해서 메소드 내에서 자체적으로 처리하고, 그 나머지는 선언부에 지정하여 호출한 메소드에서 처리하도록 함으로써, 양쪽에서 나눠서 처리되도록 할 수 있다.
  + 먼저 예외가 발생할 가능성이 있는 메소드에서 try-catch문을 사용해서 예외를 처리해주고 catch문에서 필요한 작업을 행한 후에 throw문을 사용해서 예외를 다시 발생시킨다. 다시 발생한 예외는 이 메소드를 호출한 메소드에게 전달되고 호출한 메소드의 try-catch문에서 예외를 또다시 처리한다.
