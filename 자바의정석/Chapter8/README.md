# 7. 객체지향 프로그래밍2

## 1. 상속(inheritance)

+ 1.1 상속의 정의와 장점
  + 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
  + 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드의 추가 및 변경이 매우 용이하다.
  ```
    class Child extends Parent{
      //~~~
     }
  ```
  + 조상 클래스 - 부모믈래스, 상위클래스, 기반클래스
  + 자손 클래스 - 자식클래스, 하위클래스, 파생된클래스
  + 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
  + 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
    
+ 1.2 클래스간의 관계 - 포함관계
  + 클래스 내에 다른 클래스를 멤버변수로 선언하여 간결하고 손쉽게 클래스를 작성할 수 있다.
 
+ 1.3 클래스간의 관계 결정하기
  + '~은 ~이다' - 상속관계
  + '~은 ~을 가지고 있다.' - 포함관계
 
+ 1.4 단일 상속(single inheritance)
  + 다른 객체지향언어인 C++에서는 여러 조상클래스로부터 상속받는 것인 다중 상속을 지원하지만, 자바에서는 단일 상속만을 허용한다.
 
+ 1.5 Object클래스 - 모든 클래스의 조상
  + Object클래스는 모든 클래스의 조상클래스로 상속을 정의하지 않아도 컴파일러에 의해 자동적으로 상속된다.
  + 모든 클래스들은 Object클래스의 자손이므로 Object클래스에 정의된 메소드들을 사용할 수 있다.
      
## 2. 오버라이딩(overriding)

+ 2.1 오버라이딩이란?
  + 조상 클래스로부터 상속받은 메소드의 내용을 변경하는 것을 오버라이딩이라고 한다.

+ 2.2 오버라이딩의 조건
  + 자손 클래스에서 오버라이딩하는 메소드는 조상 클래스의 메소드와 이름,매개변수,반환타입이 같아야 한다.
    1. 접근 제어자는 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.
    2. 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.
    3. 인스턴스메소드를 static메소드로 또는 그 반대로 변경할 수 없다.

+ 2.3 오버로딩 vs 오버라이딩
  + 오버로딩(overloading): 기존에 없는 새로운 메소드를 정의하는 것
  + 오버라이딩(overriding): 상속받은 메소드의 내용을 변경하는 것

+ 2.4 super
  + super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
  + 조상 클래스에 선언된 멤버변수와 같은 이름의 멤버변수를 자손 클래스에서 중복해서 정의하는 것이 가능하며 참조변수 super를 이용해서 서로 구별할 수 있다.

+ 2.5 super() - 조상 클래스의 생성자
  + super()는 조상 클래스의 생성자를 호출하는데 사용된다.
  + 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야 하는데, 그 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.
  + 생성자에 첫 줄에 생성자 this()또는 super()를 호출하지 않으면 컴파일러가 자동으로 super()를 생성자의 첫 줄에 삽입한다.


## 3. package와 import

+ 3.1 패키지(package)
  + 패키지란, 클래스의 묶음으로, 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있게 한다.

+ 3.2 패키지의 선언
  ```
  package 패키지명;
  ```
  + 위와 같이 클래스나 인터페이스의 소스파일의 맨 위에 다음과 같이 한줄만 적어주면 선언할 수 있다.
  + 모든 클래스는 반드시 하나의 패키지에 포함되어야 한다.
  + 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으러 이름없는 패키지에 속하게 된다.

+ 3.3 import문
  + 소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다.
  + 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지명은 생략할 수 있다.
        
+ 3.4 import문의 선언
  + 일반적인 소스파읠의 구성은 다음의 순서로 되어 있다.
    1. package문
    2. import문
    3. 클래스 선언
  + 클래스이름을 지정해주는 대신 '*'을 사용하면, 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용할 수 있다. - 클래스 이름을 지정하는 것과 실행 시 성능상의 차이는 전혀 없다.
 
+ 3.5 static import문
  + import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이 static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.

 
## 4. 제어자(modifier)

+ 4.1 제어자란?
  + 제어자는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
  + 제여자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

+ 4.2 static - 클래스의, 공통적인
  + static은 '클래스의' 또는 '공통적인'의 의미를 가지고 있다.
  + 멤버변수, 메서드, 초기화 블럭에 사용될 수 있다.
 
+ 4.3 final - 마지막의, 변경될 수 없는
  + final은 '마지막의' 또는 '변경될 수 없는'의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.
  + 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메소드에 사용되면 오버라이딩을 할 수 없게 되고, 클래스에 사용되면 자손 클래스를 정의하지 못하게 된다.
  + final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.
 
+ 4.4 abstract - 추상의, 미완성의
  + abstract는 '미완성'의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메소드를 선언하는데 사용된다.
  + 클래스에 사용되어 클래스 내에 추상 메소드가 존재한다는 것을 쉽게 알 수 있게 한다.
 
+ 4.5 접근 제어자(access modifier)
  + 접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
  + 클래스, 멤버변수, 메소드, 생성자에 사용될 수 있다.
    1. private - 같은 클래스 내에서만 접근이 가능하다.
    2. default - 같은 패키지 내에서만 접근이 가능하다.
    3. protected - 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능하다.
    4. public - 접근 제한이 없다.
  + 접근 제어자를 사용하는 이유(캡슐화)
    1. 외부로부터 데이터를 보호하기 위해
    2. 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해

+ 4.6 제어자의 조합
  1. 메소드에 static과 abstract를 함께 사용할 수 없다. - static은 몸통이 있는 메소드에만 사용할 수 있기 때문이다.
  2. 클래스에 abstract와 final을 동시에 사용할 수 없다 - 클래스에서 final은 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 모순된다.
  3. abstract 메소드의 접근 제어자가 private일 수 없다. - abstract 메소드는 자손 클래스에서 구현해주어야 하는데, 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문이다.
  4. 메소드에 private과 final을 같이 사용할 필요는 없다. - 접근 제어자가 private인 메소드는 오버라이딩될 수 없기 때문이다.

 
  ## 5.다형성(polymorphism)

  + 5.1 다형성이란?
    + 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미한다.
    + 자바에서는 다형성을 프로그램적으로 구현하기 위해 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다.
    + 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다. -> 자손타입의 참조변수는 조상타입의 인스턴스롤 참조할 수 없다.

  + 5.2 참조변수의 형변환
    + 자손타입 -> 조상타입 (Up-casting): 형변환 생략가능
    + 자손타입 <- 조상타입 (Down-casting): 형변환 생략불가
    + 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
    + 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.
  ```
  서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나,
  참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
  ```
  
  + 5.3 instanceof 연산자
    + 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
    + 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

  + 5.4 참조변수와 인스턴스의 연결
    + 메소드의 경우 조상 클래스의 메소드를 자손의 클래스에서 오버라이딩한 경우 참조 변수의 타입에 관계없이 항상 실제 인스턴스의 메소드가 호출되지만, 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

  + 5.5 매개변수의 다형성
    + 매개변수가 조상 타입의 참조변수라는 것은, 메소드가 매개변수로 조상 클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 뜻이다.

  + 5.6 여러 종류의 객체를 배열로 다루기
    + 조상 타입의 참조변수로 자손 타입의 객체를 참조하는 것이 가능하므로, 조상 타입의 배열의 각각 다른 자손 인스턴스롤 참조할 수 있다.
    + 배열은 크기를 초과하면 저장을 못하는 성질 때문에 Vector 클래스를 사용한다.
    + Vector클래스는 내부적으로 Object타입의 배열을 가지고 있어서 객체를 추가하거나 제거할 수 있다.
      1. Vector() - 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성한다. 10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가된다.
      2. boolean add(Object o) - Vector에 객체를 추가한다. 추가를 성공하면 결과값으로 true, 실패하면 false를 반환한다.
      3. boolean remove(Object o) - Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환한다.
      4. boolean isEmpty() - Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환한다.
      5. Object get(int index) - 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요하다.
      6. int size() - Vector에 저장된 객체의 개수를 반환한다.


  ## 6. 추상 클래스(abstract class)

  + 6.1 추상 클래스란?
    + 추상 클래스란 추상 메소드를 포함하고 있는 클래스로, 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스이다.
    + 추상 메소드를 포함하고 있기 때문에 인스턴스를 생성할 수 없다.
    + 추상클래스는 키워드 'abstract'를 class 앞에 붙이면 된다.
    + 생정자도 있고, 멤버변수와 메소드도 가질 수 있다.

  + 6.2 추상 메소드(abstract method)
    + 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상 메소드이다.
      ```
      abstarct 리턴타입 메소드이름();
      ```
    + 위와 같이 작성할 수 있다.
    + 추상 메소드를 만드는 이유는 메소드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만을 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려주는 것이다.

  + 6.3 추상 클래스의 작성
    + 여러 클래스에 공통적으로 사용될 수 있는 클래스를 바로 작성하기도 하고, 기존의 클래스의 공통적인 부분을 뽑아서 추상 클래스로 만들어 상속하도록 하는 경우도 있다.
    + 추상 메소드로 정의하지 않고, 빈 몸통만 가지도록 정의하면, 자식 클래스에서는 구현을 하지 않을 수 있지만, 추상 메소드로 정의를하면, 자식 클래스에서는 반드시 구현을 해야 한다.

  ## 7. 인터페이스(interface)

  + 7.1 인터페이스란?
    + 인터페이스는 추상클래스의 일종으로 추상 메소드와 달리 일반 메서드 또는 멤버변수를 가질 수 없고, 추상메소드와 상수만을 멤버로 가질 수 있다.

  + 7.2 인터페이스의 작성
    + 인터페이스는 클래스와 작성 방법이 비슷한데, 키워드로 class 대신 interface를 사용한다.
    ```
    interface 인터페이스이름{
        public static final 타입 상수이름 = 값;
        public abstract 메서드이름(매개변수목록);
     }
    ```
    + 일반적인 클래스 멤버들과 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다.
      1. 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
      2. 모든 메소드는 public abstract 이어야 하며, 이를 생략할 수 있다. (단 static 메소드와 디폴트 메소드는 예외)

  + 7.3 인터페이스의 상속
    + 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능하다.

  + 7.4 인터페이스의 구현
    + 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 자신에 정의된 추상 메소드의 몸통을 만들어주는 클래스를 작성해야 한다.
    ```
    class 클래스이름 implements 인터페이스이름{
      // 인터페이스에 정의된 추상 메소드
      }
    ```
    + 만일 구현하는 인터페이스의 메소드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.
    + 상속과 구현을 동시에 할 수도 있다.

  + 7.6 인터페이스를 이용한 다형성
    + 인터페이스는 인터페이스를 구현한 클래스의 조상이므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스의 타입으로의 형 변환도 가능하다.
    + 리턴타입이 인터페이스라는 것은 메소드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
   
  + 7.7 인터페이스의 장점
    1. 개발시간을 단축시킬 수 있다.
    2. 표준화가 가능하다.
    3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
    4. 독립적인 프로그래밍이 가능하다.
   
  + 7.9 디폴트 메소드와 static 메소드
    + static 메소드는 인스턴스와 관계가 없는 독립적인 메소드이므로 인터페이스에 추가할 수 있다.
    + 디폴트 메소드는 추상 메소드의 기본적인 구현을 제공하는 메소드로, 추상 메소드가 아니기 때문에 디폴트 메소드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
    + 디폴트 메소드는 앞에 키워드 default를 붙이며, 추상 메소드와 달리 일반 메소드처럼 몸통{}이 있어야 한다.
    + 새로 추가된 디폴트 메소드가 기존의 메소드와 이름이 중복되어 충돌하는 경우
      1. 여러 인터페이스의 디폴트 메소드 간의 충돌 - 인터페이스를 구현한 클래스에서 디폴트 메소드를 오버라이딩해야 한다.
      2. 디폴트 메소드와 조상 클래스의 메소드 간의 충돌 - 조상 클래스의 메소드가 상속되고, 디폴트 메소드는 무시된다.
    
## 8. 내부 클래스(inner class)

+ 8.1 내부 클래스란?
  + 내부 클래스는 클래스 내에 선언된 클래스이다.
  + 내부 클래스의 장점
    1. 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
    2. 코드의 복잡성을 줄일 수 있다.(캡슐화)

+ 8.2 내부 클래스의 종류와 특징
  + 인스턴스 클래스 - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작어벵 사용될 목적으로 선언된다.
  + 스태틱 클래스 - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static 멤버, 특히 static 메서드에 사용될 목적으로 선언된다.
  + 지역 클래스 - 외부 클래스의 메소드나 초기화블록 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
  + 익명 클래스 - 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스

+ 8.4 내부 클래스의 제어자와 접근성
  + 내부 클래스 중에서 스태틱 클래스만 static 멤버를 가질 수 있다.

+ 8.5 익명 클래스(anonymous class)
  + 익명 클래스는 다른 클래스들과 달리 이름이 없고, 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.
  + 이름이 없기 때문에 생성자도 가질 수 없으며, 조상 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.
  ```
  new 조상클래스이름(){
    // 멤버 선언
  }

  또는

  new 구현인터페이스이름(){
    //멤버 선언
  }
  ```
